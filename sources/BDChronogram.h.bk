
#ifndef BDCHRONO
#define BDCHRONO

#include "Chronogram.h"
#include <algorithm>
#include <utility>
#include <list>

class DateCopy : public Dvar<PosReal>	{

	public:

	DateCopy(NodeDate* innodedate, Var<PosReal>* inChi, Var<PosReal>* inChi2)	{
		nodedate = innodedate;
		Chi = inChi;
		Chi2 = inChi2;

		Register(nodedate);
		Register(Chi);
		Register(Chi2);
	}

	double GetLogGG()	{
		ComputeLogGG();
		return loggg;
	}

	void ComputeLogGG()	{
		if (! nodedate->isValueUpdated())	{
			cerr << "error in compute log gg\n";
		}
		// only if node is not calibrated
		loggg = 0;
		double t = nodedate->val();
		loggg = BD_logg(Chi->val(),Chi2->val(),t);
		if (isinf(loggg))	{
			cerr << "in bd chrono: inf\n";
			loggg = 1e4;
		}
	}

	void specialUpdate()	{
		// ComputeLogGG();
		setval(nodedate->val());
	}

	private:

	double BD_logg(double p1, double p2, double t)	{

		double t0 = 1;
		double ret = 0;
		if (fabs(p1) > 1e-6)	{
			double e = exp(-p1*t);

			// the P0 below is in fact P0 / rho, where 
			// P0 is the probability that a lineage appearing at time 0 is not extinct at time t
			// rho is the sampling fraction
			double P0 = p1 / (p2 + (p1-p2)*e);
			double e0 = exp(-p1*t0);
			double lognu = log(p2) + log(1 - e0) - log(p2*(1-e0) + p1*e0);
			ret = log(p2) - lognu + 2 * log(P0) - p1 * t;

			//
			// I have tried this below, but this seems a bit dangerous, numerically...
			//
			// double nu = p2 * (1-e0) / (p2*(1 - e0) + p1*e0);
			// double expret = p2 / nu * P0 * P0 * exp(-p1 * t);
			// ret = log(expret);
			if (isnan(ret))	{
				cerr << "numerical error in BD_logg\n";
				cerr << p1 << '\t' << p2 << '\n';
				cerr << t << '\t' << t0 << '\n';
				cerr << P0 << '\n';
				exit(1);
			}
			if (isinf(ret))	{
				cerr << "numerical error in BD_logg\n";
				cerr << p1 << '\t' << p2 << '\n';
				cerr << t << '\t' << t0 << '\n';
				cerr << P0 << '\n';
				exit(1);
			}
		}
		else	{
			ret = log( (1 + p2*t0) / t0 / (1 + p2*t) / (1 + p2*t));
			if (isnan(ret))	{
				cerr << "numerical error in BD_logg\n";
				cerr << p1 << '\t' << p2 << '\n';
				cerr << t << '\t' << t0 << '\n';
				exit(1);
			}
			if (isinf(ret))	{
				cerr << "numerical error in BD_logg\n";
				cerr << p1 << '\t' << p2 << '\n';
				cerr << t << '\t' << t0 << '\n';
				exit(1);
			}
		}
		return ret;
	}

	double loggg;

	NodeDate* nodedate;
	Var<PosReal>* Chi;
	Var<PosReal>* Chi2;
};

class CopyTree : public NodeValPtrTree<DateCopy>	{

	public:

	CopyTree(Chronogram* inchrono, Var<PosReal>* inchi, Var<PosReal>* inchi2)	{
		chrono = inchrono;
		chi = inchi;
		chi2 = inchi2;
		RecursiveCreate(GetRoot());
	}

	~CopyTree()	{
		RecursiveDelete(GetRoot());
	}

	Tree* GetTree() {return chrono->GetTree();}

	double GetTotalLogGG()	{
		return RecursiveGetLogGG(GetRoot());
	}

	protected:

	double RecursiveGetLogGG(const Link* from)	{
		double total = 0;
		if ((! from->isRoot()) && (! from->isLeaf()))	{
			total += GetNodeVal(from->GetNode())->GetLogGG();
		}
		for(const Link* link=from->Next(); link!=from; link=link->Next())	{
			total += RecursiveGetLogGG(link->Out());
		}
		return total;
	}

	DateCopy* CreateNodeVal(const Link* link)	{
		return new DateCopy(chrono->GetNodeDate(link->GetNode()),chi,chi2);
	}

	private:
	
	Chronogram* chrono;
	Var<PosReal>* chi;
	Var<PosReal>* chi2;
};



class BDChronogram : public Chronogram, public Rnode {

	public:

	static int NumErrorCount;

	BDChronogram(Tree* intree, Var<PosReal>* inrate, Var<PosReal>* inchi, Var<PosReal>* inchi2)	{

		DAGnode::SetName("BD Chrono");

		SetWithRoot(false);
		tree = intree;
		rate = inrate;
		chi = inchi;
		chi2 = inchi2;
		Ntaxa = GetTree()->GetSize(GetRoot());

		RecursiveCreateNode(GetRoot());
		RecursiveCreateBranch(GetRoot());

		copytree = new CopyTree(this,chi,chi2);

		RecursiveRegisterProb(GetRoot());

		/*
		Register(chi);
		Register(chi2);
		Register(scale);
		Register(alpha);
		Register(beta);
		Register(rate);
		*/

		double maxage = RecursiveSetNodesValues(GetRoot());
		RecursiveEqualizeLeafNodes(GetRoot(),maxage);
		RecursiveNormalizeTree(GetRoot(),maxage,true);
		RecursiveUpdateBranches(GetRoot());
	}

	~BDChronogram()	{
		RecursiveDeleteBranch(GetRoot());
		RecursiveDeleteNode(GetRoot());
	}

	void Sample()	{
		Chronogram::Sample();
	}
	
	void drawSample()	{
	}

	double Move(double tuning){
		return Chronogram::Move(tuning);
	}

	double GetLogProb()	{
		return Rnode::GetLogProb();
	}

	double ProposeMove(double)	{
		cerr << "error in BDChronogram: in propose move\n";
		exit(1);
		return 0;
	}

	double GetTotalLogGG()	{
		return copytree->GetTotalLogGG();
	}

	double logProb()	{
		double total = 0;
		total += GetTotalLogGG();
		total += logAbsBDUncalibratedPrior();
		return total;
	}

	void RecursiveRegisterProb(const Link* from)	{
		Register(copytree->GetNodeVal(from->GetNode()));
		for(const Link* link=from->Next(); link!=from; link=link->Next())	{
			RecursiveRegisterProb(link->Out());
		}
	}

	typedef pair<double,bool>  doublet;
	bool compare_doublet(doublet d1, doublet d2) {return d1.first < d2.first;}

	void RecursiveGetAgeList(const Link* from, list<doublet>& agelist)	{
		if (! from->isLeaf())	{
			bool tmp = from->isRoot();
			double temp = GetNodeVal(from->GetNode())->val();
			agelist.push_back(doublet(temp, tmp));
		}
		int degree = 0;
		for(const Link* link=from->Next(); link!=from; link=link->Next())	{
			RecursiveGetAgeList(link->Out(),agelist);
			degree++;
		}
		if (degree > 2)	{
			cerr << "error : BD accepts only bifurcating trees\n";
			exit(1);
		}
	}

	double logAbsBDUncalibratedPrior()	{

		double t0 = 1;
		double total = 0;

		list<doublet> agelist;
		RecursiveGetAgeList(GetRoot(),agelist);
		agelist.sort();

		double T[2];
		int I[2];
		I[0] = 0;
		T[0] = 0;
		int k = 1;
		int j = 1;
		for (list<doublet>::iterator i=agelist.begin(); i!= agelist.end(); i++)	{
			if (i->second) {
				if (k == 2)	{
					cerr << "error in BD log prob\n";
					exit(1);
				}
				I[k] = j;
				T[k] = i->first;
				k++;
			}
			j++;
		}

		for (int i=0; i<1; i++)	{
			int d = I[i+1] - I[i] - 1;
			for (int k=2; k<=d; k++)	{
				total += log(k);
			}
			double tmp = BD_logDeltaG(chi->val(),chi2->val(),T[i],T[i+1]);
			if (isinf(tmp) || isnan(tmp))	{
				cerr << "chi2 : " << *chi2 << '\n';
				exit(1);
			}
			total -= d * tmp;
		}

		return total;
	}

	double BD_logDeltaG(double p1, double p2, double t1, double t2)	{

		double t0 = 1;
		double ret = 0;
		if (fabs(t2-t1) < 1e-10)	{
			return 0;
		}
		if (fabs(p1) > 1e-6)	{
			double e0 = exp(-p1*t0);
			double lognu = log(p2) + log(1 - e0) - log(p2*(1-e0) + p1*e0);

			ret = (log(p1) + log(p2)) - lognu;
			ret -= p1*t1;
			ret += log(1 - exp(-p1*(t2-t1)));
			ret -= log(p2*(1 - exp(-p1*t1)) + p1*exp(-p1*t1));
			ret -= log(p2*(1 - exp(-p1*t2)) + p1*exp(-p1*t2));
			if (isinf(ret) || isnan(ret))	{
				cerr << "numerical error in BN_logDeltaG\n";
				cerr << p1 << '\t' << p2 << '\n';
				cerr << log(p2) << '\n';
				cerr << t1 << '\t' << t2 << '\t' << t0 << '\n';
				cerr << p1*t1 << '\n';
				cerr << log(1 - exp(-p1*(t2-t1))) << '\n';
				cerr << log(p2*(1 - exp(-p1*t1)) + p1*exp(-p1*t1)) << '\n';
				cerr << log(p2 + (p1-p2)*exp(-p1*t2)) << '\n';
				exit(1);
				ret = 0;
				NumErrorCount++;
			}
		}
		else	{
			ret = (1 + p2*t0) * t2 / t0 / (1 + p2*t2) ;
			ret -= (1 + p2*t0) * t1 / t0 / (1 + p2*t1) ;
			if (isinf(ret) || isnan(ret))	{
				NumErrorCount++;
				ret = 1;
				cerr << "numerical error in BN_logDeltaG\n";
				exit(1);
			}
			ret = log(ret);
		}
		return ret;
	}

	private:

	unsigned int Ntaxa;
	Var<PosReal>* chi;
	Var<PosReal>* chi2;
	CopyTree* copytree;
};

int BDChronogram::NumErrorCount = 0;


#endif

