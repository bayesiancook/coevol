
#include <list>
#include <fstream>
#include <sstream>
#include "Tree.h"

Tree::Tree()	{
	root = 0;
	taxset = 0;
}

Tree::Tree(const Tree* from)	{
	taxset = 0;
	root = new Link(from->root);
	root->InsertOut(root);
	RecursiveClone(from->root,root);
}

void Tree::RecursiveClone(const Link* from, Link* to)	{
	Node* node = new Node(from->GetNode());
	to->SetNode(node);
	const Link* linkfrom = from->Next();	
	Link* linkto = to;	
	while (linkfrom != from)	{
		Link* newnext = new Link(linkfrom); // newnext points to same node and branch as linkfrom
		newnext->SetNode(node);
		linkto->Insert(newnext);
		Link* newout = new Link(linkfrom->Out()); // idem, same node and branch as linkfrom->Out()
		newout->InsertOut(newnext);
		Branch* branch = new Branch(linkfrom->GetBranch());
		newnext->SetBranch(branch);
		newout->SetBranch(branch);
		RecursiveClone(linkfrom->Out(),newout);
		linkfrom = linkfrom->Next();
		linkto = linkto->Next();
	}	
}


void Tree::RecursiveDelete(Link* from)	{
	Link* link = from->Next();
	while (link != from)	{
		delete link->Out()->GetNode();
		delete link->GetBranch();
		RecursiveDelete(link->Out());
		Link* keep = link->Next();
		delete link;
		link = keep;
	}
	delete link;
}

void Tree::RecursiveCreateTBL(Link* from, int Nstate)	{
	for(Link* link=from->Next(); link!=from; link=link->Next())	{
		delete[] link->tbl;
		link->tbl = new double[Nstate+1];
		RecursiveCreateTBL(link->Out(), Nstate);
	}
	delete[] from->tbl;
	from->tbl = new double[Nstate+1];
}

void Tree::RecursiveDeleteTBL(Link* from)	{
	for(Link* link=from->Next(); link!=from; link=link->Next())	{
		RecursiveDeleteTBL(link->Out());
		delete[] link->tbl;
	}	
	delete[] from->tbl;
}

Tree::~Tree()	{
	if (root)	{
		RecursiveDelete(root);	
		root = 0;
	}
}

void Tree::RootAt(Link* from)	{
	Link* link = from->Next();
	root->AppendTo(from);
	link->AppendTo(root);
	root->SetNode(from->GetNode());
}

void Tree::EraseInternalNodeName()	{
	EraseInternalNodeName(GetRoot());
}

void Tree::EraseInternalNodeName(Link * from)	{
	if (! from->isLeaf())	{
		from->GetNode()->SetName("");
	}
	for(Link* link=from->Next(); link!=from; link=link->Next())	{
		EraseInternalNodeName(link->Out());
	}
}

/*
void Tree::RegisterWith(const TaxonSet* taxset)	{
	RegisterWith(taxset,GetRoot());		
}

void Tree::RegisterWith(const TaxonSet* taxset,Link* from)	{
	if (from->isLeaf())	{
		int i = taxset->GetTaxonIndex(from->GetNode()->GetName());
		if (i == -1)	{
			cerr << "error in tree::register with taxon set: did not find taxon name " << from->GetNode()->GetName() << " in taxon set\n";
			exit(1);
		}
		from->GetNode()->SetIndex(i);
	}
	for(Link* link=from->Next(); link!=from; link=link->Next())	{
		RegisterWith(taxset,link->Out());
	}	
}
*/

void Tree::RegisterWith(const TaxonSet* taxset)	{
	Link* newOut = RegisterWith(taxset,GetRoot());
	if(newOut ==  0){
		cerr << "This tree have nothing in common with your data\n";
		exit(1);
	}
	if(newOut != GetRoot()){
		delete GetRoot()->Next();
		delete GetRoot()->GetNode();
		delete GetRoot()->Next()->GetBranch();
		delete GetRoot();
		root = newOut;
		root->InsertOut(root);
	}
}

Link* Tree::RegisterWith(const TaxonSet* taxset,Link* from)	{
	if (from->isLeaf())	{
		int i = taxset->GetTaxonIndex(from->GetNode()->GetName());
		if (i == -1)	{
			return 0;
		}
		else{
			from->GetNode()->SetIndex(i);
			return from;
		}
	}
	else{
		Link* previous = from;
		Link* link = from->Next();
		while(link!=from)	{
			Link* newOut = RegisterWith(taxset,link->Out());
			if(newOut == 0){
				Link* forDelete = link;
				link = link->Next();
				link->AppendTo(previous);
				delete forDelete->Out()->GetNode();
				delete forDelete->Out();
				delete forDelete->GetBranch();
				delete forDelete;
			}
			else{
				if(newOut != link->Out()){
					ostringstream sum;
					sum << atof((link->GetBranch()->GetName()).c_str()) + atof((newOut->GetBranch()->GetName()).c_str());
					newOut->GetBranch()->SetName(sum.str());
					delete link->Out()->Next();
					delete link->Out()->GetNode();
					delete link->Out();
					delete link->GetBranch();
					link->InsertOut(newOut);
					link->SetBranch(newOut->GetBranch());
				}
				previous = link;
				link = link->Next();
			}
		}
		if(from->Next() == from){
			return 0;
		}
		else{
			if(from->Next()->Next() == from){
				return from->Next()->Out();
			}
			else{
				return from;
			}
		}
	}
}

typedef list<string>::const_iterator csit;

Tree::Tree(string filename)	{

	ifstream is(filename.c_str());
	if (!is)	{
		cerr << "cannot find file : " << filename << '\n';
	}
	ReadFromStream(is);
}

void Tree::ReadFromStream(istream& is)	{

	string expr = "";
	int cont = 1;
	while (cont)	{
		string s;
		is >> s;
		unsigned int k = 0;
		while ((k<s.length()) && (s[k] != ';'))	k++;
		expr += s.substr(0,k);
		cont = (! is.eof()) && (k==s.length());
	}
	SetRoot(ParseGroup(expr,0));
}

Link* Tree::ParseList(string input, Node* node)	{
	
	try	{

		// parse input as a list of strings separated by ','
		list<string> lst;
		int n = input.size();
		int k = 0;
		int brack = 0;
		int b = 0;
		while (k<n)	{
			char c = input[k];
			if (c == '(') brack++;
			if (c == ')') brack--;
			if ((!brack) && (c == ','))	{
				lst.push_back((string) (input.substr(b,k-b)));
				b = k+1;
			}

			if (brack<0)	{
				cerr << "in parse list : too many )\n";
				cerr << input.substr(0,k) << '\n';
				cerr << input << '\n';
				throw;
			}
			k++;
		}
		if (brack)	{
			cerr << "in parse list : too many (\n";
			cerr << input << '\n';
			throw;
		}
		lst.push_back(input.substr(b,k-b));

		// make a circular single link chain around the node
		// with one link for each term of the list
		// and call parse group on each term
		Link* firstlink = new Link;
		Link* prevlink = firstlink;
		firstlink->SetNode(node);
		for (csit i=lst.begin(); i!=lst.end(); i++)	{ 
			Link* link = new Link;
			link->SetNode(node);
			link->AppendTo(prevlink);
			ParseGroup(*i,link);
			prevlink = link;
		}
		firstlink->AppendTo(prevlink);
		return firstlink;
	}
	catch(...)	{
		cerr << "exit in parse list\n";
		exit(1);
	}
}

Link* Tree::ParseGroup(string input, Link* from)	{
	
	try	{

		// parse input as (body)nodeval:branchval
		
		string body = "";
		unsigned int k = 0;
		if (input[0] == '(')	{
			int brack = 1;
			k = 1;
			while ((k<input.length()) && brack)	{
				char c = input[k];
				if (c == '(') brack++;
				if (c == ')') brack--;
				k++;
			}
			if (brack)	{
				cerr << "in parse group: too many (\n";
				cerr << input << '\n';
				throw;
			}
			body = input.substr(1,k-2);
		}
		
		int b = k;
		while ((k<input.length()) && (input[k]!=':')) k++;
		string nodeval = input.substr(b,k-b);

		string branchval = "";
		if (k<input.length())	{
			branchval = input.substr(k+1, input.length() - k);
		}

		// make a new node and a new branch
		Node* node = new Node(nodeval);

		// call parse body
		Link* link = 0;
		if (body != "")	{
			link = ParseList(body,node);
		}
		else	{
			link = new Link;
			link->SetNode(node);
		}
		if (from)	{
			Branch* branch = new Branch(branchval);
			link->SetBranch(branch);
			from->SetBranch(branch);
			link->InsertOut(from);
		}
		return link;
	}
	catch(...)	{
		cerr << "exit in parse group\n";
		exit(1);
	}
}

void Tree::Print(ostream& os, const Link* from)	const {

	if (!from->isLeaf())	{
		os << '(';
		for (const Link* link=from->Next(); link!=from; link=link->Next())	{
			Print(os,link->Out());
			if (link->Next() != from)	{
				os << ',';
			}
		}
		os << ')';
	}
	os << GetNodeName(from);
	if (!from->isRoot())	{
		string brval = GetBranchName(from);
		if (brval != "")	{
			os << ':' << brval;
		}
	}
}
		
void Tree::Print(ostream& os)	const {
	Print(os,GetRoot());
	os << ";\n";
}

